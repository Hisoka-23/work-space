package com.faceRecogntion.FaceRecognition;

import java.io.File;
import java.io.FilenameFilter;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.Comparator;

import javax.swing.JOptionPane;

import org.bytedeco.javacpp.opencv_core;
import org.bytedeco.javacpp.opencv_core.Mat;
import org.bytedeco.javacpp.opencv_core.MatVector;
import org.bytedeco.javacpp.opencv_core.Size;
import org.bytedeco.javacpp.opencv_face.FaceRecognizer;
import org.bytedeco.javacpp.opencv_imgcodecs;
import org.bytedeco.javacpp.opencv_imgproc;

import static org.bytedeco.javacpp.opencv_face.createLBPHFaceRecognizer;

public class YaleTraining {
	public static void main(String[] args) {
		//Yale training();
	}

	public void yaleTraining() {

		File directory = new File("E:\\prakash\\WorkSpace\\Face-Recognition\\FaceRecognition\\src\\main\\resources\\faces\\training");
		FilenameFilter imageFilter = new FilenameFilter() { // filter image type
			public boolean accept(File dir, String name) {
				String n = name.toLowerCase();
				return n.endsWith(".jpg") || n.endsWith(".gif") || n.endsWith(".png");
			}
		};
		
		File[] files = directory.listFiles(imageFilter);// vector to store the images according to the filter
		if(files == null || files.length == 0){
			JOptionPane.showMessageDialog(null, "No training images found in photos folder.","FACE RECOGNITION",JOptionPane.ERROR_MESSAGE);
			return;
		}

		//Deterministic order to avoid missing the "last" person due to arbitrary FS ordering
		Arrays.sort(files, Comparator.comparing(File::getName));
		
		MatVector photos = new MatVector(files.length);//save archived photos
		Mat labels = new Mat(files.length, 1, opencv_core.CV_32SC1);//record name/labels of photos
		IntBuffer bufferLabels = labels.createBuffer();// to store the labels
		int counter = 0;//count images

		/*for (File image : files) { 
			  Mat photo = opencv_imgcodecs.imread(image.getAbsolutePath(), opencv_imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);
//			  int personId = Integer.parseInt(image.getName().substring(5,10));
			  
			  String name = image.getName(); // e.g., "subject1.png" or "1.png" [6]
			  int dot = name.lastIndexOf('.');
			  String base = (dot >= 0) ? name.substring(0, dot) : name; // remove extension [6]

			  // Option A: extract the first run of digits anywhere in the base name
			  java.util.regex.Matcher m = java.util.regex.Pattern.compile("(\\d+)").matcher(base); // digits only [1]
			  if (!m.find()) {
			      // No numeric label; skip this file or log a warning
			      System.err.println("Skipping file without numeric label: " + name); // [2]
			      continue;
			  }
			  int personId = Integer.parseInt(m.group(1)); // safe: only digits now [2][4]
			  
			// proceed with image preprocessing and labeling
			  opencv_imgproc.resize(photo, photo, new Size(160, 160)); 
			  photos.put(counter, photo); 
			  bufferLabels.put(counter, personId); 
			  counter++; 
		  }
		 */

		 for( File image : files) {// fill in the data to train classifiers
			Mat photo = opencv_imgcodecs.imread(image.getAbsolutePath(), opencv_imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);//take the image by name and convert to gray scale
			if(photo == null || photo.empty()) {
				System.out.println("Skip unreadable: "+ image.getName());
			}
			
			// Parse label from filename pattern: name.id.ext (kept intact, only validated)
            String[] name = image.getName().split("\\.");
            if (name.length < 3) {
                System.out.println("Skip invalid filename (expected name.id.ext): " + image.getName());
                continue;
            }
			
			//String name=image.getName().split("\\.")[0].substring(0);
            
            int personId;
            try {
                personId = Integer.parseInt(name[1]);
            } catch (NumberFormatException ex) {
                System.out.println("Skip non-numeric id in filename: " + image.getName());
                continue;
            }
            
			//int personId = Integer.parseInt(image.getName().split("\\.")[1]);// search person id

            //Normalize size and contrast
			opencv_imgproc.resize(photo, photo, new Size(200,200));
			opencv_imgproc.equalizeHist(photo, photo);//improves robustness for LBPH
			//add to training set
			photos.put(counter, photo);//search photo
			bufferLabels.put(counter,personId);  //search person id
			
			//Helpful log for debugging the last entries
			System.out.printf("Train: %s -> id=%d (%dx%d)%n",
                    image.getName(), personId, photo.arrayWidth(), photo.arrayHeight());
			counter++;
		}

		if (counter == 0) {
            JOptionPane.showMessageDialog(null, "No valid images after parsing/validation.","FACE RECOGNITION",JOptionPane.ERROR_MESSAGE);
            return;
        }

		// Prepare recognizer (create or load existing)
		FaceRecognizer lbph = createLBPHFaceRecognizer();
		File modelFile = new File("E:\\prakash\\WorkSpace\\Face-Recognition\\FaceRecognition\\src\\main\\resources\\classifierLBPH.yml");
		if (modelFile.exists()) {
		    lbph.load(modelFile.getAbsolutePath()); // continue from previous state
		} else {
			modelFile.getParentFile().mkdir();
		}

		/*FaceRecognizer lbph = createLBPHFaceRecognizer(12, 10, 15, 15, 0);

		lbph.train(photos, labels);
		lbph.save("E:\\prakash\\WorkSpace\\Face-Recognition\\FaceRecognition\\src\\main\\resources\\classifierLBPH.yml");
		JOptionPane.showMessageDialog(null, "Training Complete!", "FACE RECOGNITION", JOptionPane.INFORMATION_MESSAGE);
		*/

		if (modelFile.exists()) {
		    lbph.update(photos, labels);
		} else {
		    lbph.train(photos, labels);
		}
		lbph.save(modelFile.getAbsolutePath());
	}
}