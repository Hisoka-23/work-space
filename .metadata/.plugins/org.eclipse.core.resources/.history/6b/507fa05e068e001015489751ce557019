package com.faceRecogntion.FaceRecognition;

import static org.bytedeco.javacpp.opencv_face.createEigenFaceRecognizer;
import static org.bytedeco.javacpp.opencv_face.createFisherFaceRecognizer;
import static org.bytedeco.javacpp.opencv_face.createLBPHFaceRecognizer;

import java.io.File;
import java.io.FilenameFilter;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.Comparator;

import javax.swing.JOptionPane;

import org.bytedeco.javacpp.opencv_core;
import org.bytedeco.javacpp.opencv_core.Mat;
import org.bytedeco.javacpp.opencv_core.MatVector;
import org.bytedeco.javacpp.opencv_core.Size;
import org.bytedeco.javacpp.opencv_face.FaceRecognizer;
import org.bytedeco.javacpp.opencv_imgcodecs;
import org.bytedeco.javacpp.opencv_imgproc;

public class Training {

	public static void main(String[] args) {
		//training();
	}
	public void training()
	{
		File directory = new File ("E:\\prakash\\WorkSpace\\Face-Recognition\\FaceRecognition\\src\\main\\resources\\photos");
		FilenameFilter imageFilter = new FilenameFilter() {   // filter image type
			public boolean accept(File dir, String name) {
				String n = name.toLowerCase();
				return n.endsWith(".jpg") || n.endsWith(".gif") || n.endsWith(".png");
			}
		}; 

		File[] files = directory.listFiles(imageFilter);// vector to store the images according to the filter
		if(files == null || files.length == 0) {
			JOptionPane.showMessageDialog(null, "No training images found in photos folder.","FACE RECOGNITION",JOptionPane.ERROR_MESSAGE);
			return;
		}
		
		//Deterministic order to avoid missing the "last" person due to arbitrary FS ordering
		Arrays.sort(files, Comparator.comparing(File::getName));
		
		MatVector photos = new MatVector(files.length);// save archived photos
		Mat labels = new Mat(files.length, 1 , opencv_core.CV_32SC1);  //record name/labels of photos
		IntBuffer bufferLabels = labels.createBuffer();  //to store the labels
		int counter = 0;  //count images

		for( File image : files) {// fill in the data to train classifiers
			Mat photo = opencv_imgcodecs.imread(image.getAbsolutePath(), opencv_imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);//take the image by name and convert to gray scale
			if(photo == null || photo.empty()) {
				System.out.println("Skip unreadable: "+ image.getName());
			}
			
			// Parse label from filename pattern: name.id.ext (kept intact, only validated)
            String[] name = image.getName().split("\\.");
            if (name.length < 3) {
                System.out.println("Skip invalid filename (expected name.id.ext): " + image.getName());
                continue;
            }
			
			//String name=image.getName().split("\\.")[0].substring(0);
            
            int personId;
            try {
                personId = Integer.parseInt(name[1]);
            } catch (NumberFormatException ex) {
                System.out.println("Skip non-numeric id in filename: " + image.getName());
                continue;
            }
            
			//int personId = Integer.parseInt(image.getName().split("\\.")[1]);// search person id

            //Normalize size and contrast
			opencv_imgproc.resize(photo, photo, new Size(160,160));
			opencv_imgproc.equalizeHist(photo, photo);//improves robustness for LBPH
			//add to training set
			photos.put(counter, photo);//search photo
			bufferLabels.put(counter,personId);  //search person id
			
			//Helpful log for debugging the last entries
			System.out.printf("Train: %s -> id=%d (%dx%d)%n",
                    image.getName(), personId, photo.arrayWidth(), photo.arrayHeight());
			counter++;
		}
		
		if (counter == 0) {
            JOptionPane.showMessageDialog(null, "No valid images after parsing/validation.","FACE RECOGNITION",JOptionPane.ERROR_MESSAGE);
            return;
        }

        // If some files were skipped, trim to actual count
        if (counter != files.length) {
            photos = photos.position(0); // ensure position reset
            MatVector trimmedPhotos = new MatVector(counter);
            Mat trimmedLabels = new Mat(counter, 1, opencv_core.CV_32SC1);
            IntBuffer trimmedBuf = trimmedLabels.createBuffer();
            for (int i = 0; i < counter; i++) {
                trimmedPhotos.put(i, photos.get(i));
                trimmedBuf.put(i, labels.createBuffer().get(i));
            }
            photos = trimmedPhotos;
            labels = trimmedLabels;
            bufferLabels = trimmedBuf;
        }

		FaceRecognizer lbph = createLBPHFaceRecognizer();

		lbph.train(photos, labels);
		lbph.save("E:\\prakash\\WorkSpace\\Face-Recognition\\FaceRecognition\\src\\main\\resources\\classifierLBPH.yml");
		JOptionPane.showMessageDialog(null, "Training Faces Done!","FACE RECOGNITION",JOptionPane.INFORMATION_MESSAGE);
	}
}